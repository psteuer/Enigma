package enigma;

import org.junit.Assert;

import org.junit.Test;

/**
 * Testing Class for Cipher functions
 *
 */
public class Tester {

    Encrypt etest128 = new Encrypt(4,10,4);
    Decrypt dtest = new Decrypt(4,10,4);
    EnigmaView theView = new EnigmaView();
    Encrypt encrypt = new Encrypt(4,10,4);
    Decrypt decrypt = new Decrypt(4,10,4);
    EnigmaController control = new EnigmaController();

    int[][] SecondKeyRound = {{0xe2, 0x91, 0xB1, 0xD6}, {0x32, 0x12, 0x59, 0x79}, {0xFC, 0x91, 0xe4, 0xA2}, {0xf1, 0x88, 0xe6, 0x93}};
    int[][] FirstRoundState = {{0xBA, 0x84, 0xE8, 0x1b}, {0x75, 0xA4, 0x8D, 0x40}, {0xF4, 0x8D, 0x06, 0x7D}, {0x7A, 0x32, 0x0E, 0x5D}};
    int[][] SecondKeyRoundANDFirstRoundStateYEILD = {{0x58, 0x15, 0x59, 0xCD}, {0x47, 0xb6, 0xD4, 0x3}, {0x08, 0x1c, 0xe2, 0xdf}, {0x8b, 0xba, 0xe8, 0xce}};

    //Test Vectors
    int[][] shiftTest = {{0x63, 0xEB, 0x9F, 0xA0}, {0xC0, 0x2F, 0x93, 0x92}, {0xAB, 0x30, 0xAF, 0xC7}, {0x20, 0xCB, 0x2B, 0xA2}};
    int[][] shiftLeftAns = {{0x63, 0xEB, 0x9F, 0xA0}, {0x2F, 0x93, 0x92, 0xC0}, {0xAF, 0xC7, 0xAB, 0x30}, {0xA2, 0x20, 0xCB, 0x2B}};

    int[][] stateTest = {{0x54, 0x4F, 0x4E, 0x20}, {0x77, 0x6E, 0x69, 0x54}, {0x6F, 0x65, 0x6E, 0x77}, {0x20, 0x20, 0x65, 0x6F}};
    int[][] keyTest = {{0x54, 0x73, 0x20, 0x67}, {0x68, 0x20, 0x4B, 0x20}, {0x61, 0x6D, 0x75, 0x46}, {0x74, 0x079, 0x6E, 0x75}};
    int[][] RooundKeyans = {{0x00, 0x3C, 0x6E, 0x47}, {0x1F, 0x4E, 0x22, 0x74}, {0x0E, 0x08, 0x1B, 0x31}, {0x54, 0x59, 0x0B, 0x1A}};

    int[][] subbytesAns = {{0x63, 0xEB, 0x9F, 0xA0}, {0xC0, 0x2F, 0x93, 0x92}, {0xAB, 0x30, 0xAF, 0xC7}, {0x20, 0xCB, 0x2B, 0xA2}};

    int[][] MixInput = {{0x63, 0xEB, 0x9F, 0xA0}, {0x2F, 0x93, 0x92, 0xC0}, {0xAF, 0xC7, 0xAB, 0x30}, {0xA2, 0x20, 0xCB, 0x2B}};
    int[][] MixOutput = {{0xBA, 0x84, 0xE8, 0x1B}, {0x75, 0xA4, 0x8D, 0x40}, {0xF4, 0x8D, 0x06, 0x7D}, {0x7A, 0x32, 0x0E, 0x5D}};

    int[][] keyIn = {{0x2b, 0x7e, 0x15, 0x16}, {0x28, 0xae, 0xd2, 0xa6}, {0xab, 0xf7, 0x15, 0x88}, {0x09, 0xcf, 0x4f, 0x3c}};

    int[][] key = {{0x54, 0x68, 0x61, 0x74}, {0x73, 0x20, 0x6D, 0x79}, {0x20, 0x4B, 0x75, 0x6E}, {0x67, 0x20, 0x46, 0x75}};
    int[][] stateKeyInput = {{0x54, 0x4F, 0x4E, 0x20}, {0x77, 0x6E, 0x69, 0x54}, {0x6F, 0x65, 0x6E, 0x77}, {0x20, 0x020, 0x65, 0x6F}};

    // int[][] PlainText = {{0x54, 0x77, 0x6F, 0x20}, {0x4F, 0x6E, 0x65, 0x20}, {0x4E, 0x69, 0x6E, 0x65}, {0x20, 0x54, 0x77, 0x6F}};
    int[][] CipherText = {{0x29, 0x57, 0x40, 0x1a}, {0xc3, 0x14, 0x22, 0x02}, {0x50, 0x20, 0x99, 0xD7}, {0x5f, 0xf6, 0xb3, 0x3A}};

    String str = "Thats my Kung Fu";
    String strShort = "Thats m";

    @Test
    public void testShiftRows() {
        Assert.assertArrayEquals(shiftLeftAns, etest128.myShiftRows(shiftTest));//check!
    }

    @Test
    public void testinvShiftRows() {
        Assert.assertArrayEquals(shiftTest, dtest.myInvShiftRows(shiftLeftAns)); //Double checked!
    }

    @Test
    public void testAddRoundKey() {
        Assert.assertArrayEquals(RooundKeyans, etest128.AddRoundKey(stateTest, keyTest, 0)); //check!
    }

    @Test
    public void testSubBytes() {
        Assert.assertArrayEquals(subbytesAns, etest128.SubBytes(RooundKeyans)); //check!
    }

    @Test
    public void testinvSubBytes() {
        Assert.assertArrayEquals(RooundKeyans, dtest.invSubBytes(subbytesAns)); //Double Checked!
    }

    @Test
    public void testMixColumns() {
        Assert.assertArrayEquals(MixOutput, etest128.MixColumns(MixInput)); //
    }

    @Test
    public void testInvMixColumns() {
        Assert.assertArrayEquals(MixInput, dtest.InvMixColumns(MixOutput));//good
    }

    @Test
    public void format() {
        Assert.assertArrayEquals(keyTest, control.format("Thats my Kung Fu", "PlainText", 4)); //key good
    }

    @Test
    public void TestFormatStrToInt() {
        Assert.assertArrayEquals(keyTest, control.formatStrToInt("Thats my Kung Fu", "PlainText",  4)); //good
    }

    @Test
    public void testPadding() {
        Assert.assertEquals(str.length(), control.padding(strShort, 4).length());
    }

    @Test
    public void testRand() {
        theView.setkeytext("0123456789101112");
        Assert.assertEquals(16, theView.getkeytext().length());
    }

    @Test
    public void TestformatIntToStr() {
        //   Assert.assertEquals("Thats my Kung Fu", control.formatIntToStr(key));
    }

    @Test
    public void TestEncrypt() {
        Assert.assertArrayEquals(CipherText, etest128.Encipher(stateTest, keyTest));//good
    }

    @Test
    public void SecondTestEncrypt() {
        int[][] zero = {{0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00}};
        int[][] ZeroEans = {{0x66, 0xEF, 0x88, 0xCA}, {0xE9, 0x8A, 0x4C, 0x34}, {0x4b, 0x2c, 0xfa, 0x2b}, {0xd4, 0x3b, 0x59, 0x2e}};
        Assert.assertArrayEquals(ZeroEans, etest128.Encipher(zero, zero));//good

    }

    @Test
    public void SecondTestDecrypt() {
        int[][] ZeroEans = {{0x66, 0xEF, 0x88, 0xCA}, {0xE9, 0x8A, 0x4C, 0x34}, {0x4b, 0x2c, 0xfa, 0x2b}, {0xd4, 0x3b, 0x59, 0x2e}};
        int[][] zero = {{0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00}, {0x00, 0x00, 0x00, 0x00}};
        Assert.assertArrayEquals(zero, dtest.decipher(ZeroEans, zero));//good

    }

    @Test
    public void TestDecrypt() {
        Assert.assertArrayEquals(stateTest, dtest.decipher(CipherText, key));//good
    }

    @Test
    public void testRightShift() {
        int[] rightshiftIn = {0x2F, 0x93, 0x92, 0xC0};
        int[] rightshiftOUT = {0xC0, 0x2F, 0x93, 0x92};
        Assert.assertArrayEquals(rightshiftOUT, dtest.shiftRight(rightshiftIn, 1));//good
    }

    @Test
    public void testLeftShift() {
        int[] rightshiftIn = {0x2F, 0x93, 0x92, 0xC0};
        int[] rightshiftOUT = {0xC0, 0x2F, 0x93, 0x92};
        Assert.assertArrayEquals(rightshiftIn, dtest.shiftRight(rightshiftOUT, 3));//good
    }

    @Test
    public void testKeyCore() {
        int[] temp = {0x09, 0xcf, 0x4f, 0x3c};
        int[] ans = {0x8b, 0x84, 0xeb, 0x01};
        int rconplace = 1;
        Assert.assertArrayEquals(ans, etest128.KeyCore(temp, rconplace));//good
    }

    @Test
    public void secondKeyCoreTest() {
        int[] temp = {0x2a, 0x6c, 0x76, 0x05};
        int[] ans = {0x52, 0x38, 0x6b, 0xe5};
        int rconplace = 2;
        Assert.assertArrayEquals(ans, dtest.KeyCore(temp, rconplace));//good
    }

    @Test
    public void SecondAddRoundKeyTest() {
        int[][] SecondKeyRound = {{0xe2, 0x91, 0xB1, 0xD6}, {0x32, 0x12, 0x59, 0x79}, {0xFC, 0x91, 0xe4, 0xA2}, {0xf1, 0x88, 0xe6, 0x93}};
        int[][] FirstRoundState = {{0xBA, 0x84, 0xE8, 0x1b}, {0x75, 0xA4, 0x8D, 0x40}, {0xF4, 0x8D, 0x06, 0x7D}, {0x7A, 0x32, 0x0E, 0x5D}};
        int[][] SecondKeyRoundANDFirstRoundStateYEILD = {{0x58, 0x15, 0x59, 0xCD}, {0x47, 0xb6, 0xD4, 0x3}, {0x08, 0x1c, 0xe2, 0xdf}, {0x8b, 0xba, 0xe8, 0xce}};
        Assert.assertArrayEquals(SecondKeyRoundANDFirstRoundStateYEILD, etest128.AddRoundKey(FirstRoundState, SecondKeyRound, 1));
    }    
    @Test
    public void testPlain(){
        Assert.assertEquals("Two One Nine Two", control.intTostr(stateTest, false));
    }
    
    @Test
    public void test256(){
        int[][] LongKey = {{0x60, 0x3d ,0xeb ,0x10 },{0x15 ,0xca, 0x71, 0xbe},{ 0x2b, 0x73, 0xae, 0xf},{ 0x85, 0x7d, 0x77, 0x81 },{0x1f, 0x35, 0x2c ,0x07},{ 0x3b, 0x61, 0x08, 0xd7},{ 0x2d, 0x98, 0x10, 0xa3},{ 0x09, 0x14, 0xdf, 0xf4}};
    }
            

}
